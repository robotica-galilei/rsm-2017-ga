
va deciso come utilizzare cosalfa dei tof e del gyro


definizioni: 

relative al robot

key={N, S, E, O, NE, NO, EN, ES, SE, SO, ON, ES}

key200={N, S, E, O}

key60={NE, NO, EN, ES, SE, SO, ON, ES}

side 

key.side ritorna la prima lettera di ciascun sensore.

value_side(side): N=1, E=1, S=-1, O=-1



k(key): 1 se key =  NE, SE, 0 se key = N, S -1 se key =  NO, SO else "error"




relative al campo

dir= {0,1,2,3}

value_dir(dir): 1 se dir = 2, 3, -1 se dir = 0, 1



costanti:

df60 = distanza "frontale" tra tof60 = 98 mm

dl = distanza "laterale" tra tof = 130 

ql60 = errore "laterale" tra tof60 = 1 mm

ql200 = errore "laterale" tra tof200 = 3 mm

dim = 300 mm da settare o impostabile come variabile

a = 1 determina quanto influisce l'angolo rispetto alla distanza

v_standard = 50 se go_straight, 0 se rotate da definire e capire se farla dipendere da anche dalla distanza dal centro della cella.

k1, k2, k3: determinare sia quelle per il go_straight che per il rotate


interpretazione gyro per orientamento

0.	cosalfa 	cos rotazione del robot lungo l'asse verticale

1.	cosbeta		cos rotazione del robot lungo l'asse NS

2.	cosgamma	cos rotazione del robot lungo l'asse EO

3.	cosangolo 	ritorna cosbeta side è se E o O o ritorna cosgamma se side è N o S

valori tof

funzioni

0.	get_trusted(key)       se tofraw(key) è un dato buono o no
				z = 1 se buono z = 0 se marcio -> ritorna z
	
1.	tof(key) = (tofraw(key) -ql200*(key si trova in key200) - ql60*(key si trova in key60)) *cosangolo(key.side))

2.	tof200(side): tof(side) [N, S, E, O]

indicati key e side rispettivi
//speculari lungo gli assi
3a.	tof60_1(side)= tof(key) 	key	ES, OS, NO, SO
					side	E ,O ,N ,S

3b.	tof60_2(side)= tof(key) 	key	EN, ON, NE, SE
					side	E, O, N, S

//speculari con centro nell'origine

4a.	tof60_a(side)= tof(key) 	key 	N0, OS , SE , EN
					side	N, O, S, E

4b.	tof60_b(side)= tof(key) 	key	NE, ON, SO, ES
					side	N, O, S ,E

interpretazione tof per orientamento

variabili

1a.	side_miny		minore fra la media di side:  N e S 

1b.	side_minx		minore fra la media di side: E e O 

1c.	side_min		minore fra la media di side: N, S, E e O 

7.	N_miny			numero di celle in side_miny (numero minimo di celle che dista da una parete davanti o dietro)

8.	N_minx			numero di celle in side_minx (numero minimo di celle che dista da una parete destra o sinistra)

funzioni

1.	media(side)		media dei sensori "buoni" su ogni lato 
					media = (tof60_1(side) + tof200(side) + tof60_2(side))/(get_trusted(tof60_1(side)) + get_trusted(tof200(side)) + get_trusted(tof60_2(side))) -> ritorna media

2. 	differenza(side) 	differenza =  (get_trusted(tof60_a(side)) * (tof60_a(side) -  tof200(side)) - get_trusted(tof60_b(side)) * (tof60_b(side) -  tof200(side)))/(get_trusted(tof60_a(side)) + get_trusted(tof60_b(side))) -> ritorna differenza

3a.	cosalfa(side) 		cosalfa= 1 / sqrt(1 + ((differenza(side) / df60)^2)) -> ritorna cosalfa 

3b.	senalfa(side)		senalfa= (differenza(side) / df60) / sqrt(1 + ((differenza(side) / df60)^2)) -> ritorna senalfa... notare come può essere positivo o negativo

4. 	dist_eff(side)		media(side) * cosalfa

5. 	N(media)			N appartiene a Naturali
					N=media(sideminy)*cosalfa / dim			->ritorna N





orientamento

funzioni

1a.	et_straight = dim (1 + N_minx) - (2 * media(sideminx) + dl) / (a + 1)*(1 + a * cosalfa) * value_dir //per go_straight

1b.	et_rotate = cosalfa

2.	P(et) = k1 * et(t)

3. 	D(et) = k2 * (et(t)-et(t-1))

4.	I(et) = k3 * integrale(et) dt

5. 	PID(et) = P(et) * I(et) * D(et)

6.	v_right = v_standard + PID

7.	v_left = v_standard - PID


esplorazione


1.	dist_centrale(side) = dist_eff(side) + dl/2

2.	dist_sensory(key) = dist_centrale(key.side) + df * k(key) + senalfa


	immaginavo di dividere ciascuna cella in 2. questo ci permette di capire se ci sono o no oggetti agli angoli delle celle.
	misuriamo poi la frequenza dei risultati delle misurazioni
	se nelle due metà di una cella i vari sensori su una frequenza dominante di visione del muro, allora muro, se invece vedono lungo allora no_muro
	se nella prima metà della cella attuale e nella seconda metà della cella precedente compare una frequenza cospiqua ( ho calcolato con i fati forniti dal regolamento il valore), allora ostacolo.
	questo vale sia per fronte che per i due lati. 
	per i due lati utilizziamo la misurazione di un tof(key) e per determinare la posizione dist_sensorx(key)
	per il fronte è più semplice.

	
 	

funzioni