costanti:

df60 = distanza "frontale" tra tof60 = 98 mm

dl = distanza "laterale" tra tof = 120 

ql60 = errore "laterale" tra tof60 = 1.5 mm

ql200 = errore "laterale" tra tof200 = 3 mm

dim = 300 mm da settare o impostabile come variabile

a = 1 determina quanto influisce l'angolo rispetto alla distanza

v_standard = 50 se go_straight, 0 se rotate da definire e capire se farla dipendere da anche dalla distanza dal centro della cella.

k1, k2, k3: determinare sia quelle per il go_straight che per il rotate


interpretazione gyro per orientamento

0.	cosalfa 	rotazione del robot lungo l'asse verticale

1.	cosbeta		cos dell'angolo lungo E O

2.	cosgamma	cos dell'angolo lungo N S



valori tof

funzioni

0.	get_trusted(tof)	tof60 e tof200 buoni 
						z = 1 se buono z = 0 se marcio -> ritorna z

1a.	tof60_1(side)		if side è N o S	cosangolo=cosgamma
						if side è E o O	cosangolo=cosbeta
						tof60_1 = (READTOF - ql60) * cosangolo	->ritorna tof60_1
						
1b.	tof60_2(side)		if side è N o S	cosangolo=cosgamma
						if side è E o O	cosangolo=cosbeta
						tof60_2 = (READTOF - ql60) * cosangolo	->ritorna tof60_2

1c.	tof200(side)		if side è N o S	cosangolo=cosgamma
						if side è E o O	cosangolo=cosbeta
						tof200 = (READTOF - ql200) * cosangolo	->ritorna tof200	



interpretazione tof per orientamento

funzioni

1.	media(side)		media dei sensori "buoni" su ogni lato 
					media = (get_trusted(tof60_1(side)) * tof60_1(side) + get_trusted(tof200(side)) * tof200(side) + get_trusted(tof60_2(side)) * tof60_2(side))/(get_trusted(tof60_1(side)) + get_trusted(tof200(side)) + get_trusted(tof60_2(side))) -> ritorna media

2a.	side_miny(...)		minore fra la media di side:  N e S -> ritorna N o S

2b.	side_minx(...)		minore fra la media di side: E e O -> ritorna E o O

3.	side_min(...)		minore fra la media di side: N, S, E e O -> ritorna N, S, E o O

5. 	differenza(side) 	differenza = (get_trusted(tof60_1(side)) * (tof60_1(side) -  get_trusted(tof 200(side)) * tof200(side)) - get_trusted(tof60_2(side)) * (tof60_2(side) - get_trusted(tof 200(side)) * tof200(side)))/(get_trusted(tof60_1(side)) + get_trusted(tof60_2(side))) -> ritorna differenza

6.	cosalfa(side) 		cosalfa= 1 / sqrt(1 + ((differenza(side) / df60)^2)) -> ritorna cosalfa 

7.	N_miny			numero di celle dove side=side_miny
					N appartiene a Naturali
					N=media(sideminy) / dim			->ritorna N

8.	N_minx			numero di celle dove side=side_minx
					N appartiene a Naturali
					N=media(sideminx) / dim			->ritorna N




orientamento

va deciso come utilizzare cosalfa dei tof e del gyro

funzioni

0.	u_dir è la direzione universale  u_dir = 1 se ... u_dir = - 1 se ...

1a.	et_straight = dim (1 + N_minx) - (2 * media(sideminx) + dl) / (a + 1)*(1 + a * cosalfa) * u_dir //per go_straight

1b.	et_rotate = cosalfa

2.	P(et) = k1 * et(t)

3. 	D(et) = k2 * (et(t)-et(t-1))

4.	I(et) = k3 * integrale(et) dt

5. 	PID(et) = P(et) * I(et) * D(et)

6.	v_right = v_standard + PID

7.	v_left = v_standard - PID